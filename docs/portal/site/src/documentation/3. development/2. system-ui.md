---
title: System UI
layout: default
---

Like everything in IndiGO, its UI also consists of plugins:
[_frontend_ plugins](/indigo/documentation/development/frontend-plugins). They expose _panels_ which
contain a visual user interface for the functionality within the frontend's domain. These panels can
be seen as pieces of the complete user interface. To enable a high degree of flexibility within the
IndiGO framework, there is no direct coupling between different frontends or their panels, allowing
plugins to be independently added, removed or replaced.

Even though frontends are not coupled, IndiGO presents the frontend panels to users in a cohesive
way. The _system UI_ is a plugin that decides when to show which panel and defines the container to
place the panels in. In common usage, each `Activity` uses a single system UI instance in its
content view; IndiGO provides [`IviActivity`](TTIVI_INDIGO_API) that does just that. Different 
system UIs can be used per display, hosted in multiple or a single `Activity`.

## The Model-View-ViewModel pattern (MVVM) used in the system UI

Similarly to how [frontends](/indigo/documentation/development/frontend-plugins) follow the
[MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) pattern, so does the
system UI. In this pattern:

- The model consists of the panels that frontends expose.
- The view model is the system UI's logic to determine which panels to show.
- The view is the container to place the panels in.

### Model

The model contains the information that the system UI presents in the view. It consists of the
complete set of panels exposed by the set of frontends. Each system UI instance can have a different
set of frontends, depending on the _IVI instance_ that it represents; see
[runtime deployment](/indigo/documentation/tutorials-and-examples/deployment/configure-the-runtime-deployment-of-the-ivi-system)
for more information on multiple IVI instances. Frontends decide internally when to expose a certain
panel and when to close it. Common situations where a frontend opens a panel include:

- At launch, where a frontend always wants to show a certain panel, like a main menu panel.
- Through a system callback to
  [Frontend.openTaskPanels](https://developer.tomtom.com/assets/downloads/indigo/indigo-api/latest/api_framework_frontend/com.tomtom.ivi.api.framework.frontend/-frontend/open-task-panels.html),
  in response to a menu item being clicked.
- Responding to a service update, like opening a notification panel when the telecom service
  indicates there is an incoming call.
- User interaction within the frontend, like showing more details when clicking on a list entry
  within a task panel.

While the frontend is ultimately in control of the panels it contains, the system UI also has
influence over the lifetime of the panels. For example, when the user dismisses a panel by swiping
it away, the system UI requests that the frontend removes it.

### View Model

The model contains the full set of panels that can be shown. However, it may not be suitable to show
all of them at once. There are various situations in which a panel offered by a frontend should not
be displayed to a user. The view model decides when to show which panel. It may, for example, choose
not to show:

- A low priority notification, like a text message, when the system UI is already showing a high
  priority notification, like incoming phone call. This is done to not overload the driver with
  information.
- A low priority process bar, like a media player, when a high priority process bar, like for an
  ongoing call, is more relevant to the driver.
- The search panel on the home screen when a guidance panel is available for an active route, in
  order to not clutter the home screen.

In addition to the panels to show, the view model provides the view with other information needed to
properly show the system UI. For example, the view model also informs the view of the active theme
or the placement of the main menu based on the product configuration.

### View

The view inflates an Android layout and populates it using the information of the view model. It
exposes an Android [`View`](https://developer.android.com/reference/android/view/View) which can be
integrated in an [`Activity`](https://developer.android.com/reference/android/app/Activity),
[`VirtualDisplay`](https://developer.android.com/reference/android/hardware/display/VirtualDisplay),
or any place where IndiGO should be presented.

In order to visualize panels, it asks the panel for an Android
[`Fragment`](https://developer.android.com/reference/androidx/fragment/app/Fragment). This fragment is
implemented within the frontend and contains views as a regular Android fragment would. The fragment
is added to the system UI's fragment manager and placed inside a container within the system UI's
layout. The container itself may also be a rich component, including style (background color,
rounded corners, shadows, etc.), animations (like for showing and hiding panels) and logic (like to
swipe away a panel).

__Note:__ Panels should avoid specifying styles, animations, etc. internally, to allow the system UI
to create a consistent look and feel across all panels.

## Separation of concerns

As the system UI is a plugin itself, frontends and their panels should avoid making assumptions
about it. Similarly, the system UI avoids making assumptions about which frontends are available, or
their contents. This low coupling allows both the system UI and the other plugins to be configured
differently per product.

It is important however, that the system UI and the frontends integrate neatly. To achieve this, the
IndiGO framework provides a set of contracts in the form of interfaces and classes, that allow a
basic level of interaction between the system UI and frontends.

The majority of these contracts are defined in [`api_framework_frontend`](TTIVI_INDIGO_API). Apart
from the core classes [`Frontend`](TTIVI_INDIGO_API) and [`Panel`](TTIVI_INDIGO_API), the various
predefined extensions of [`Panel`](TTIVI_INDIGO_API) allow the system UI to recognize how to present
that type of panel. For example, by having a frontend panel extend
[`NotificationPanel`](TTIVI_INDIGO_API), the system UI knows to treat that panel as a notification,
and can judge whether or not to show it based on the priority specified in the
[`NotificationPanel`](TTIVI_INDIGO_API) properties.

In addition to the system UI getting information from frontends and panels, the contract also
contains methods that allow the system UI to pass information back. For example, when a panel is
attached to the system UI, `Panel.onAttached` will be called with a 
[`PanelContext`](TTIVI_INDIGO_API) parameter, that allows the panel to use a limited set of 
information from the system UI for its contents.

## Frontends

Frontends expose panels, which the system UI processes and presents when appropriate. Panels are
used for a wide range of functionalities. This is not limited to opening panels when pressing a menu
item, but also notifications, process bars, and even the menu itself.

### Panel types

IndiGO offers a fixed set of panel types that can be used by the system UI.

__Note:__ As part of an upcoming API for creating custom system UI plugins, capabilities will be
added to create custom panel types for frontends to use.

#### Home panel

The home panel is the main element shown on the screen when starting IndiGO. IndiGO's default home
panel contains a map that allows the user to plan a trip somewhere and navigate to it. A frontend
can provide an home panel by adding a panel that extends [`HomePanel`](TTIVI_INDIGO_API) to its
panels.

#### Main menu panel

The main menu panel provides a way of accessing the other system frontends. Main menu panels
commonly depend on the [`MenuService`](TTIVI_INDIGO_API), which provides the menu items and handles
user selections. This allows the menu frontend itself to not have any dependencies on other
frontends directly. A frontend can provide a menu by adding a panel that extends
[`MainMenuPanel`](TTIVI_INDIGO_API) to its panels.

#### Process bar panels

Frontends can visualize ongoing processes in the UI using process bar panels, which can be created
by adding a panel that extends [`ProcessBarPanel`](TTIVI_INDIGO_API) to the frontend's panels. This
can be used, for example, to show an ongoing audio streaming process or during a phone call. The
process bar panel's metadata is used by the system UI to determine the priority of when to show
certain process bar panels. For example, an ongoing phone call has a higher priority than streaming
media. When both these frontends provide a process bar panel at the same time, the process bar for
phone calls will be shown instead of the one for media.

#### Task panels

Tapping on a menu item in IndiGO's main menu commonly leads to a panel sliding open. This panel is
called a _task panel_, and it can be created by adding a panel that extends
[`TaskPanel`](TTIVI_INDIGO_API) to the frontend's panels. It allows the user to perform a certain
task, after which the panel typically is closed again. Task panels can be thought of as an "app"
within IndiGO.

Task panels can be stacked to create a user flow through various screens. The top-most task panel
will be shown to the user, and when that panel is removed, the next task panel on the stack will be
shown.

A header with a consistent look and feel across other task panels can be added by placing the
[`TtNavigationBar`](TTIVI_ANDROID_TOOLS_API) control in the panel's layout. This is typically placed
in the top-left of the panel, but may be placed anywhere. Task panels can set a number of attributes
related to presentation on the navigation bar, but they do not have to specify its contents. The
system UI is aware that task panels may contain navigation bars and will populate them using the
information from the task panel stack.

For example, the system UI may hide the back button in the navigation bar if there's only one task
panel in the stack. It may also fill in the breadcrumbs for quick access to other task panels in the
stack. This allows the task panel itself to remain decoupled from all other task panels, and it does
not need to know about the content of the stack. The metadata in the task panel interface, such as
the label, can be used to provide the information shown in the navigation bar.

Task panels derive from [`DismissablePanel`](TTIVI_INDIGO_API) and may be dismissed by the user
through system UI functionality, like swiping it away. Such an action can trigger the system UI to
dismiss the whole task panel stack, rather than just a single one.

#### Task process bar panel

A task process bar panel allows a frontend to visualize an ongoing processe in all of its task
panels. Unlike the process bar, a task process bar panel is part of the task panel and as such does
not overlap the task panel itself.

IndiGO's system UI may hide the process bar when a task panel is opened. However, if the process is
relevant to that task panel, it likely wants to continue presenting that process to the user, for
example, to show a mini player for the currently playing music. In these cases, the frontend can add
a panel extending [`TaskProcessBarPanel`](TTIVI_INDIGO_API), which the system UI will show next to 
the task panel itself within the task panel's container. The task process bar panel will persist for 
the whole task panel stack. When task panels get added and removed from the stack, the same task 
process bar panel will continue to be visible. A frontend's task process bar panel will only be 
shown if it also has an active task panel, and will not be shown for task panels of other frontends.

#### Notification panels

IndiGO notifications are created by adding a panel that extends
[`NotificationPanel`](TTIVI_INDIGO_API) to the frontend's panels. Through this interface, metadata
such as the priority can be passed to the system UI. The system UI uses this metadata to determine
when and how to show the notification. For example, it may choose to suppress a low priority
notification while a higher priority notification is active to avoid distracting the driver.

Notification panels derive from [`DismissablePanel`](TTIVI_INDIGO_API) and may be dismissed by the
user through system UI functionality, like swiping it away.

#### Modal panels

A modal panel is a _floating_ panel that blocks all other user interaction until it has been
dismissed. They are used to display information that:

- Needs attention from the user in order to give instructions or critical information.
- Requires information in order to continue with a service or workflow.

Modal panels interrupt a user's workflow by design. When active, a user is blocked from the task
panel or home panel content. They cannot return to their previous workflow until the modal task is
completed or the modal panel has been dismissed.

Modal panels are used for short and non-frequent tasks, such as logging into an account, Bluetooth
device pairing, making small changes, or management tasks. If a user needs to repeatedly perform a
task, consider letting the user perform it in the original panel. Modal panels can be created by
adding a panel that extends [`ModalPanel`](TTIVI_INDIGO_API) to the frontend's panels.

Modal panels can be stacked to create a user flow through various screens. The top-most modal panel
will be shown to the user. When that panel is dismissed, the next modal panel on the stack will be
shown.

A header with a consistent look and feel across other modal panels can be added by placing a
[`TtNavigationBar`](TTIVI_ANDROID_TOOLS_API) in the panel's layout. This is typically placed in the
top-left of the panel, but may be placed anywhere. Modal panels can set a number of attributes
related to presentation on the navigation bar, but do not have to specify its contents. The system
UI is aware that modal panels may contain navigation bars and will populate them using the
information from the modal panel stack.

For example, the system UI may hide the back button in the navigation bar if there's only one modal
panel in the stack. Or it may fill in breadcrumbs for quick access to other modal panels in the
stack. This allows the modal panel itself to remain decoupled from other modal panels, and does not
have to know about the stack's contents. The metadata in the modal panel interface, such as the
label, can be used to provide the information shown in the navigation bar.

Modal panels derive from [`DismissablePanel`](TTIVI_INDIGO_API) and may be dismissed by the user
through system UI functionality, like clicking a close button. Such an action can trigger the system
UI to dismiss the whole modal panels stack, rather than just a single one.

#### Control center panels

IndiGO's control center is an isolated area of the system UI that provides persistent indicators and
controls, that are accessible to the user at all times. For example, a clock or temperature
controls. It is populated with various panels extending [`ControlCenterPanel`](TTIVI_INDIGO_API). 
The metadata set in the panel's interface lets the system UI determine where to show the panel. For
example, a panel with its `type` property set to `SYSTEM_STATUS_DRIVER` will be shown somewhere
easily accessible by the driver and may be positioned differently depending on the location of the
steering wheel.

#### Search panel

The search panel offers quick access to search functionality. This panel is meant to provide a
visual context for location based search, such as searching for a driving destination, parking spots
or charging stations. A frontend can add this search functionality by adding a panel that extends
[`SearchPanel`](TTIVI_INDIGO_API) to its panels.

__Note:__ The search panel is explicitly _not_ meant for searching content within a task panel, like
songs within a media frontend.

#### Guidance panel

The guidance panel displays guidance information for the active trip. A frontend can provide that
guidance information by adding a panel that extends [`GuidancePanel`](TTIVI_INDIGO_API) to its 
panels.

#### Overlay panels

Frontends can overlay the system UI using overlay panels, which can be created by adding a panel
that extends [`OverlayPanel`](TTIVI_INDIGO_API) to the frontend's panels. Overlay panels are used to
show a temporary visual effect over the system UI's main content area. This can be used, for
example, to visualize the state of a currently active VPA or provide large and noticeable navigation
instructions.

## Panel templates

Some panels in various plugins have a very similar layout. For example, most notifications have an
icon, text and buttons arranged in the same way. These panel-specific layouts are offered by IndiGO
in the shape of _templates_ that request a view model and put the information that it contains in
the right place.

These templates are implemented in the form of a base fragment class. In order to use a template,
your panel's fragment should extend one of these base template fragments. The view model referred to
by your fragment must then also extend the `ViewModel` type used by that template fragment. The
properties in that template `ViewModel` can be set by your own view model to populate the template.

__Note:__ It is not strictly necessary to use a template. If your panel uses a different layout,
then extending the regular [`IviFragment`](TTIVI_INDIGO_API) instead of the template's fragment gives
you full control over the contents.

IndiGO offers templates for:

- Notifications
- Process bars
- Modals

### Notification template

The default template for [`NotificationPanel`](TTIVI_INDIGO_API)s can be used by extending
[`NotificationFragment`](TTIVI_INDIGO_API) and [`NotificationViewModel`](TTIVI_INDIGO_API) from
[`core_common_notification`](TTIVI_INDIGO_API).

[TODO(IVI-5615)]: # (Add UX design of notification template)

### Process bar template

The default template for [`ProcessBarPanel`](TTIVI_INDIGO_API)s can be used by extending
[`ProcessBarFragment`](TTIVI_INDIGO_API) and [`ProcessBarViewModel`](TTIVI_INDIGO_API) from
[`core_common_processbar`](TTIVI_INDIGO_API).

[TODO(IVI-5616)]: # (Add UX design of process bar template)

### Modal template

The default template for [`ModalPanel`](TTIVI_INDIGO_API)s can be used by extending
[`ModalPanelFragment`](TTIVI_INDIGO_API) and [`ModalPanelViewModel`](TTIVI_INDIGO_API) from
[`core_common_modalpanel`](TTIVI_INDIGO_API).

[TODO(IVI-5617)]: # (Add UX design of model template)

## Safe area

When panels are overlapped by other panels or system UI elements, the system UI can inform panels of
that through the _safe area_ in [`PanelContext`](TTIVI_INDIGO_API). The safe area indicates the amount
of space from each side of a panel that is not safe to display important content due to the panel
being overlapped by others.

For example, when the process bar opens, it will cover the bottom part of the home panel. The system
UI informs the home panel that a certain amount of pixels from the bottom is now hidden. The map
display home panel then uses this information to make sure the chevron isn't shown below the process
bar, by moving it upwards. (The _chevron_ is the blue arrow that indicates the current location on
the map.) When doing so, the home panel must still draw the map outside of the safe area because
that area might not be covered in its entirety. For example, the process bar has space on either
side where the map is still visible.

## See also

All of IndiGO's [UI components](/indigo/documentation/development/ui-components).
