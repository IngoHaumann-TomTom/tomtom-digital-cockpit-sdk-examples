#!/usr/bin/env python3

'''
This script takes a BlackDuck compliance report in JSON format and renders it in a human readable
format, like a list or a table in MarkDown.
'''

import os
import sys
import argparse
import json
from types import SimpleNamespace

class Formatter:
    '''Output formatter for the license information.'''

    def begin(self, project, metadata):
        '''Called once for each Formatter, to render a document header.'''
        pass

    def write(self, component):
        '''Called for each component with all its known versions.'''
        print("ERROR: Do not use abstract base class to produce output.")
        exit(1)

    def end(self):
        '''Called once for each Formatted, to render a document footer.'''
        pass

    def headers(self, metadata):
        '''Returns all headers in the metadata as a single string.'''
        return "\n".join(metadata.headers)

class MarkDownFormatter(Formatter):
    def begin(self, project, metadata):
        print(f"# OSS list for _{project.name}_ version {project.version}\n")
        print(f"{self.headers(metadata)}\n")

class SimpleMarkDownFormatter(MarkDownFormatter):
    '''A simple line by line MarkDown output formatter.'''

    def write(self, component):
        is_plural = len(component.versions) > 1
        print(f"\"[{component.name}]({component.url})\" version{'s' if is_plural else ''} "
            + f"{', '.join(component.versions)} {'are' if is_plural else 'is'} "
            + f"licensed under {component.license}\n")

class TableMarkDownFormatter(MarkDownFormatter):
    '''A MarkDown table output formatter. It has three columns:
    component name, version, and license.'''

    def begin(self, project, metadata):
        super().begin(project, metadata)
        print('| Component | Version | License |')
        print('| :-------- | :------ | :------ |')

    def write(self, component):
        print(f"| [{component.name}]({component.url}) | {', '.join(component.versions)}"
            + f" | {component.license} |")

class CsvFormatter(Formatter):
    '''A Comma Separated Values output formatter.
    It has four columns: component name, version, license, and URL.
    '''

    def begin(self, _project, _metadata):
        print('"Component", "Version", "License", "URL"')
    
    def write(self, component):
        print(f"\"{self.escape(component.name)}\", "
            + f"\"{self.escape(', '.join(component.versions))}\", "
            + f"\"{self.escape(component.license)}\", \"{self.escape(component.url)}\"")

    def escape(self, string):
        return string.replace('"', '\\"')

class Component:
    '''Simple container to collect all versions of a component.'''

    def __init__(self, json):
        self.name = json.name
        self.url = json.url
        self.license = json.license.display
        self.versions = []

def create_components(data):
    '''Converts the given JSON data into a map of component names to their Component instance.'''

    # Map component names to a map of version numbers to license ID's.
    components = {}
    for item in data.components:
        if item.name not in components:
            # Create a new component and add to the map.
            components[item.name] = Component(item)
        component = components[item.name]

        # Add potential new version.
        versions = components[component.name].versions
        if item.version not in versions:
            versions.append(item.version)

    return components

def write_output(formatter, project, metadata, components):
    '''Output the license display name for each version of each component.'''

    formatter.begin(project, metadata)

    for name, component in components.items():
        # Try to output in TASL format: Title, Author, Source, License.
        # Since we do not have the Author information, we'll have to leave that out. That
        # information is made available, however, by following the source URL.
        formatter.write(component)

    formatter.end()

def main(args):
    try:
        # Load the JSON data.
        content = open(args.blackduck_report).read()
    except FileNotFoundError as err:
        print(err)
        exit(1)
    data = json.loads(content, object_hook = lambda d: SimpleNamespace(**d))
    components = create_components(data)

    # Generate the requested output.
    if args.markdown_list:
        write_output(SimpleMarkDownFormatter(), data.project, data.metadata, components)
    if args.markdown_table:
        write_output(TableMarkDownFormatter(), data.project, data.metadata, components)
    if args.csv:
        write_output(CsvFormatter(), data.project, data.metadata, components)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description = "Generate a license report based on the JSON file generated by BlackDuck.",
        usage = f"{os.path.basename(sys.argv[0])} [options] <blackduck_report>")
    parser.add_argument("blackduck_report", help="JSON file generated by BlackDuck.")
    parser.add_argument('-l', '--markdown-list', default = False, action = 'store_true',
        help="Output a simple list in MarkDown format.")
    parser.add_argument('-t', '--markdown-table', default = False, action = 'store_true',
        help="Output a table in MarkDown format.")
    parser.add_argument('-c', '--csv', default = False, action = 'store_true',
        help="Output a table in Comma Separated Values (CSV) format. "
            + "Can also be imported into a spreadsheet.")
    args = parser.parse_args()
    main(args)
